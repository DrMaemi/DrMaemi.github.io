---
title: '[백준] 1107번 리모컨 (파이썬)'
author_profile: true
toc_label: '[백준] 1107번 리모컨 (파이썬)'
post-order: 6
---

문제 링크 - [https://www.acmicpc.net/problem/1107](https://www.acmicpc.net/problem/1107)

## 코드
```python::lineons
N, M = int(input()), int(input())

broken = set()
ans = abs(N-100)

if M: broken = set(input().strip())

for n in range(10**6+1):
    if not set(str(n))&broken:
        ans = min(ans, len(str(n))+abs(N-n))

print(ans)
```

## 풀이
처음엔 자리수마다 비교하면서 그리디 알고리즘을 통해 풀이하려고 했는데, 반례들을 생각하다 보니 그리디 풀이는 어려울 거란 생각이 들었다.

달리 규칙이 없기 때문에 단순히 브루트 포스로 풀이해야 한다. 채널 `N`이 500,000까지 될 수 있는데, `N`의 자릿수가 `m`일 때 `m+1` 자리수의 번호를 입력하고 `-`버튼을 누르는 경우가 정답인 경우에 주의해야 한다. 이 경우 `m+1` 자리수의 가장 큰 자리의 수는 반드시 1이다. 2나 3, 그 이상인 어떤 경우에도 `m` 자리수를 처음 입력하는 경우보다 더 적게 버튼을 입력할 수 없다.

따라서 최대 500,000인 어떤 채널 `N`을 가장 적은 버튼으로 찾기 위해선 숫자 1 버튼이 고장나지 않는 경우 첫 입력 채널로 최대 1,000,000까지 검사해야 한다. 한 편 채널 `N`의 자리수 `m = 6`(십만 단위)일 때 숫자 0 버튼이 망가진 경우 반드시 동일한 자리수를 가진 수를 첫 입력으로 삼아야 한다(최대 500,000이기 때문).
